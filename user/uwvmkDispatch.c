/*                                                -*-buffer-read-only: t-*-
 * **********************************************************
 * Copyright 2004 VMware, Inc.  All rights reserved. -- VMware Confidential
 * **********************************************************
 */

/*
 * uwvmkDispatch.c --
 *
 * AUTOMATICALLY GENERATED FILE.  HAND EDITS WILL BE LOST!
 *
 * Generated by  : bora/support/scripts/syscallGen.pl (via support/scripts/uwvmkGen)
 * Generated from: bora/vmkernel/user/uwvmkSyscall.list
 */

#include "uwvmkDispatch.h"

/* Prototypes for unpack functions. */
static void UWVMKSyscallUnpackGetSyscallVersion(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackLockPage(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackProbeMPN(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackGetNextAnonPage(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackReadVMKStack(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackGetMPNContents(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackSetMPNContents(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackBreakIntoDebugger(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackLiveCoreDump(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackRPCConnect(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackRPCGetMsg(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackRPCSendMsg(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackRPCReply(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackCreateVCPU(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackBindVCPU(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackReleaseAllVCPUs(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackGetCPUkhzEstimate(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackGetNumCPUsUsed(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackGetNumLogicalCPUsPerPackage(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackGetCPUIDs(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackSetVMXInfo(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackSetUID(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackSetupPhysMemMap(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackReleasePhysMemMap(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackMemTestMap(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackAsyncCheckActions(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackAddPage(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackReadPage(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackReadRegs(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackRunWorld(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackNetConnect(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackNetDisconnect(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackUsingVMKTcpIpStack(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackDelaySCSICmds(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackPhysMemIO(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackVSCSICreateDev(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackVSCSIDestroyDev(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackOpenCowHierarchy(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackCowCombine(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackMarkCheckpoint(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackCheckpointCleanup(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackSaveMemory(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackMigrateWriteCptData(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackMigratePollForData(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackMigrateReadCptData(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackInitMigration(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackInb(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackOutb(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackSysAlert(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackIsCosPidAlive(VMKFullUserExcFrame * const rawFrame);
static void UWVMKSyscallUnpackGetCosProxyPid(VMKFullUserExcFrame * const rawFrame);

/* Syscall dispatch table: */
UWVMKSyscall_Handler UWVMKSyscall_HandlerTable[] = {
    /*   0 */ UWVMKSyscallUnpackGetSyscallVersion,
    /*   1 */ UWVMKSyscallUnpackLockPage,
    /*   2 */ UWVMKSyscallUnpackProbeMPN,
    /*   3 */ UWVMKSyscallUnpackGetNextAnonPage,
    /*   4 */ UWVMKSyscallUnpackReadVMKStack,
    /*   5 */ UWVMKSyscallUnpackGetMPNContents,
    /*   6 */ UWVMKSyscallUnpackSetMPNContents,
    /*   7 */ UWVMKSyscallUnpackBreakIntoDebugger,
    /*   8 */ UWVMKSyscallUnpackLiveCoreDump,
    /*   9 */ UWVMKSyscallUnpackRPCConnect,
    /*  10 */ UWVMKSyscallUnpackRPCGetMsg,
    /*  11 */ UWVMKSyscallUnpackRPCSendMsg,
    /*  12 */ UWVMKSyscallUnpackRPCReply,
    /*  13 */ UWVMKSyscallUnpackCreateVCPU,
    /*  14 */ UWVMKSyscallUnpackBindVCPU,
    /*  15 */ UWVMKSyscallUnpackReleaseAllVCPUs,
    /*  16 */ UWVMKSyscallUnpackGetCPUkhzEstimate,
    /*  17 */ UWVMKSyscallUnpackGetNumCPUsUsed,
    /*  18 */ UWVMKSyscallUnpackGetNumLogicalCPUsPerPackage,
    /*  19 */ UWVMKSyscallUnpackGetCPUIDs,
    /*  20 */ UWVMKSyscallUnpackSetVMXInfo,
    /*  21 */ UWVMKSyscallUnpackSetUID,
    /*  22 */ UWVMKSyscallUnpackSetupPhysMemMap,
    /*  23 */ UWVMKSyscallUnpackReleasePhysMemMap,
    /*  24 */ UWVMKSyscallUnpackMemTestMap,
    /*  25 */ UWVMKSyscallUnpackAsyncCheckActions,
    /*  26 */ UWVMKSyscallUnpackAddPage,
    /*  27 */ UWVMKSyscallUnpackReadPage,
    /*  28 */ UWVMKSyscallUnpackReadRegs,
    /*  29 */ UWVMKSyscallUnpackRunWorld,
    /*  30 */ UWVMKSyscallUnpackNetConnect,
    /*  31 */ UWVMKSyscallUnpackNetDisconnect,
    /*  32 */ UWVMKSyscallUnpackUsingVMKTcpIpStack,
    /*  33 */ UWVMKSyscallUnpackDelaySCSICmds,
    /*  34 */ UWVMKSyscallUnpackPhysMemIO,
    /*  35 */ UWVMKSyscallUnpackVSCSICreateDev,
    /*  36 */ UWVMKSyscallUnpackVSCSIDestroyDev,
    /*  37 */ UWVMKSyscallUnpackOpenCowHierarchy,
    /*  38 */ UWVMKSyscallUnpackCowCombine,
    /*  39 */ UWVMKSyscallUnpackMarkCheckpoint,
    /*  40 */ UWVMKSyscallUnpackCheckpointCleanup,
    /*  41 */ UWVMKSyscallUnpackSaveMemory,
    /*  42 */ UWVMKSyscallUnpackMigrateWriteCptData,
    /*  43 */ UWVMKSyscallUnpackMigratePollForData,
    /*  44 */ UWVMKSyscallUnpackMigrateReadCptData,
    /*  45 */ UWVMKSyscallUnpackInitMigration,
    /*  46 */ UWVMKSyscallUnpackInb,
    /*  47 */ UWVMKSyscallUnpackOutb,
    /*  48 */ UWVMKSyscallUnpackSysAlert,
    /*  49 */ UWVMKSyscallUnpackIsCosPidAlive,
    /*  50 */ UWVMKSyscallUnpackGetCosProxyPid,
};

unsigned int UWVMKSyscall_HandlerTableLen = ARRAYSIZE(UWVMKSyscall_HandlerTable);

#ifdef VMX86_LOG
const char* UWVMKSyscall_NameTable[] = {
    /*   0 */ "GetSyscallVersion",
    /*   1 */ "LockPage",
    /*   2 */ "ProbeMPN",
    /*   3 */ "GetNextAnonPage",
    /*   4 */ "ReadVMKStack",
    /*   5 */ "GetMPNContents",
    /*   6 */ "SetMPNContents",
    /*   7 */ "BreakIntoDebugger",
    /*   8 */ "LiveCoreDump",
    /*   9 */ "RPCConnect",
    /*  10 */ "RPCGetMsg",
    /*  11 */ "RPCSendMsg",
    /*  12 */ "RPCReply",
    /*  13 */ "CreateVCPU",
    /*  14 */ "BindVCPU",
    /*  15 */ "ReleaseAllVCPUs",
    /*  16 */ "GetCPUkhzEstimate",
    /*  17 */ "GetNumCPUsUsed",
    /*  18 */ "GetNumLogicalCPUsPerPackage",
    /*  19 */ "GetCPUIDs",
    /*  20 */ "SetVMXInfo",
    /*  21 */ "SetUID",
    /*  22 */ "SetupPhysMemMap",
    /*  23 */ "ReleasePhysMemMap",
    /*  24 */ "MemTestMap",
    /*  25 */ "AsyncCheckActions",
    /*  26 */ "AddPage",
    /*  27 */ "ReadPage",
    /*  28 */ "ReadRegs",
    /*  29 */ "RunWorld",
    /*  30 */ "NetConnect",
    /*  31 */ "NetDisconnect",
    /*  32 */ "UsingVMKTcpIpStack",
    /*  33 */ "DelaySCSICmds",
    /*  34 */ "PhysMemIO",
    /*  35 */ "VSCSICreateDev",
    /*  36 */ "VSCSIDestroyDev",
    /*  37 */ "OpenCowHierarchy",
    /*  38 */ "CowCombine",
    /*  39 */ "MarkCheckpoint",
    /*  40 */ "CheckpointCleanup",
    /*  41 */ "SaveMemory",
    /*  42 */ "MigrateWriteCptData",
    /*  43 */ "MigratePollForData",
    /*  44 */ "MigrateReadCptData",
    /*  45 */ "InitMigration",
    /*  46 */ "Inb",
    /*  47 */ "Outb",
    /*  48 */ "SysAlert",
    /*  49 */ "IsCosPidAlive",
    /*  50 */ "GetCosProxyPid",
};

#else /* VMX86_LOG */
const char * UWVMKSyscall_NameTable[] = { };
#endif /* VMX86_LOG */
unsigned int UWVMKSyscall_NameTableLen = ARRAYSIZE(UWVMKSyscall_NameTable);


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetSyscallVersion --
 *
 * Generated from prototype:
 *   GetSyscallVersion(uint32* version +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetSyscallVersion(VMKFullUserExcFrame * const rawFrame) {
    uint32 kernel__version;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetSyscallVersion);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetSyscallVersion(&kernel__version);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ebx,
                              &kernel__version,
                              sizeof(kernel__version));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackLockPage --
 *
 * Generated from prototype:
 *   LockPage(VPN userVPN, MPN* outMPN +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackLockPage(VMKFullUserExcFrame * const rawFrame) {
    MPN kernel__outMPN;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_LockPage);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_LockPage((VPN)(rawFrame->regs.ebx),
                                       &kernel__outMPN);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ecx,
                              &kernel__outMPN,
                              sizeof(kernel__outMPN));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackProbeMPN --
 *
 * Generated from prototype:
 *   ProbeMPN(VPN userVPN, MPN* outMPN +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackProbeMPN(VMKFullUserExcFrame * const rawFrame) {
    MPN kernel__outMPN;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_ProbeMPN);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_ProbeMPN((VPN)(rawFrame->regs.ebx),
                                       &kernel__outMPN);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ecx,
                              &kernel__outMPN,
                              sizeof(kernel__outMPN));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetNextAnonPage --
 *
 * Generated from prototype:
 *   GetNextAnonPage(World_ID worldID, MPN inMPN,
 *    MPN* outMPN +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetNextAnonPage(VMKFullUserExcFrame * const rawFrame) {
    MPN kernel__outMPN;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetNextAnonPage);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetNextAnonPage((World_ID)(rawFrame->regs.ebx),
                                              (MPN)(rawFrame->regs.ecx),
                                              &kernel__outMPN);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.edx,
                              &kernel__outMPN,
                              sizeof(kernel__outMPN));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackReadVMKStack --
 *
 * Generated from prototype:
 *   ReadVMKStack(World_ID worldId, int pageNum, uint8* data,
 *    VA* vaddr +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackReadVMKStack(VMKFullUserExcFrame * const rawFrame) {
    VA kernel__vaddr;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_ReadVMKStack);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_ReadVMKStack((World_ID)(rawFrame->regs.ebx),
                                           (int)(rawFrame->regs.ecx),
                                           (UserVA)(rawFrame->regs.edx),
                                           &kernel__vaddr);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.esi,
                              &kernel__vaddr,
                              sizeof(kernel__vaddr));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetMPNContents --
 *
 * Generated from prototype:
 *   GetMPNContents(MPN mpn, uint8* buf) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetMPNContents(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetMPNContents);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetMPNContents((MPN)(rawFrame->regs.ebx),
                                             (UserVA)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackSetMPNContents --
 *
 * Generated from prototype:
 *   SetMPNContents(MPN mpn, const uint8* buf) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackSetMPNContents(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_SetMPNContents);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_SetMPNContents((MPN)(rawFrame->regs.ebx),
                                             (UserVA)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackBreakIntoDebugger --
 *
 * Generated from prototype:
 *   BreakIntoDebugger(void* fullFrame) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackBreakIntoDebugger(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_BreakIntoDebugger);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_BreakIntoDebugger((UserVA)(rawFrame->regs.ebx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackLiveCoreDump --
 *
 * Generated from prototype:
 *   LiveCoreDump(char *coreFileName, int coreFileNameLen) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackLiveCoreDump(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_LiveCoreDump);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_LiveCoreDump((UserVA)(rawFrame->regs.ebx),
                                           (int)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackRPCConnect --
 *
 * Generated from prototype:
 *   RPCConnect(
 *   const char *name +STRING[RPC_CNX_NAME_LENGTH],
 *    int *cnxFD +OUT, int32 *cnxID +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackRPCConnect(VMKFullUserExcFrame * const rawFrame) {
    char * kernel__name = NULL;
    int kernel__cnxFD;
    int32 kernel__cnxID;
    VMK_ReturnStatus status = VMK_OK;
    User_CartelInfo* uci = MY_USER_CARTEL_INFO;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_RPCConnect);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        kernel__name = (char *)User_HeapAlloc(uci, sizeof(char) * RPC_CNX_NAME_LENGTH);
        if (kernel__name == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyInString(kernel__name,
                                   rawFrame->regs.ebx,
                                   RPC_CNX_NAME_LENGTH);
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_RPCConnect(kernel__name,
                                         &kernel__cnxFD,
                                         &kernel__cnxID);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ecx,
                              &kernel__cnxFD,
                              sizeof(kernel__cnxFD));
    }
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.edx,
                              &kernel__cnxID,
                              sizeof(kernel__cnxID));
    }

    /* Free heap objects */
    if (kernel__name != NULL) {
       User_HeapFree(uci, kernel__name);
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackRPCGetMsg --
 *
 * Generated from prototype:
 *   RPCGetMsg(int32 cnxFD, RPC_MsgInfo *msgInfo,
 *    uint32 timeout, int32 isBlocking,
 *    World_ID switchToWorldID) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackRPCGetMsg(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_RPCGetMsg);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_RPCGetMsg((int32)(rawFrame->regs.ebx),
                                        (UserVA)(rawFrame->regs.ecx),
                                        (uint32)(rawFrame->regs.edx),
                                        (int32)(rawFrame->regs.esi),
                                        (World_ID)(rawFrame->regs.edi));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackRPCSendMsg --
 *
 * Generated from prototype:
 *   RPCSendMsg(int32 cnxFD, int32 rpcFunction, char *msgBuf,
 *    int32 msgBufLen) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackRPCSendMsg(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_RPCSendMsg);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_RPCSendMsg((int32)(rawFrame->regs.ebx),
                                         (int32)(rawFrame->regs.ecx),
                                         (UserVA)(rawFrame->regs.edx),
                                         (int32)(rawFrame->regs.esi));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackRPCReply --
 *
 * Generated from prototype:
 *   RPCReply(int32 cnxFD, int32 token) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackRPCReply(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_RPCReply);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_RPCReply((int32)(rawFrame->regs.ebx),
                                       (int32)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackCreateVCPU --
 *
 * Generated from prototype:
 *   CreateVCPU(VMnix_CreateWorldArgs *args +DEEPCOPY,
 *    SharedAreaDesc *desc +ARRAY[MAX_SHARED_AREA_DESC],
 *    World_ID *worldID +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackCreateVCPU(VMKFullUserExcFrame * const rawFrame) {
    VMnix_CreateWorldArgs kernel__args;
    SharedAreaDesc * kernel__desc = NULL;
    World_ID kernel__worldID;
    VMK_ReturnStatus status = VMK_OK;
    User_CartelInfo* uci = MY_USER_CARTEL_INFO;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_CreateVCPU);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        status = User_CopyIn(&kernel__args,
                             rawFrame->regs.ebx,
                             sizeof(kernel__args));
    }
    if (status == VMK_OK) {
        kernel__desc = (SharedAreaDesc *)User_HeapAlloc(uci, sizeof(SharedAreaDesc) * MAX_SHARED_AREA_DESC);
        if (kernel__desc == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyIn(kernel__desc,
                             rawFrame->regs.ecx,
                             sizeof(SharedAreaDesc) * MAX_SHARED_AREA_DESC);
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_CreateVCPU(&kernel__args,
                                         kernel__desc,
                                         &kernel__worldID);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.edx,
                              &kernel__worldID,
                              sizeof(kernel__worldID));
    }

    /* Free heap objects */
    if (kernel__desc != NULL) {
       User_HeapFree(uci, kernel__desc);
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackBindVCPU --
 *
 * Generated from prototype:
 *   BindVCPU(World_ID groupLeaderID, int32 vcpuID,
 *    World_ID *worldID +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackBindVCPU(VMKFullUserExcFrame * const rawFrame) {
    World_ID kernel__worldID;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_BindVCPU);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_BindVCPU((World_ID)(rawFrame->regs.ebx),
                                       (int32)(rawFrame->regs.ecx),
                                       &kernel__worldID);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.edx,
                              &kernel__worldID,
                              sizeof(kernel__worldID));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackReleaseAllVCPUs --
 *
 * Generated from prototype:
 *   ReleaseAllVCPUs() 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackReleaseAllVCPUs(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_ReleaseAllVCPUs);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_ReleaseAllVCPUs();
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetCPUkhzEstimate --
 *
 * Generated from prototype:
 *   GetCPUkhzEstimate(uint32 *cpukHzEstimate +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetCPUkhzEstimate(VMKFullUserExcFrame * const rawFrame) {
    uint32 kernel__cpukHzEstimate;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetCPUkhzEstimate);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetCPUkhzEstimate(&kernel__cpukHzEstimate);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ebx,
                              &kernel__cpukHzEstimate,
                              sizeof(kernel__cpukHzEstimate));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetNumCPUsUsed --
 *
 * Generated from prototype:
 *   GetNumCPUsUsed(uint32 *numCPUs +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetNumCPUsUsed(VMKFullUserExcFrame * const rawFrame) {
    uint32 kernel__numCPUs;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetNumCPUsUsed);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetNumCPUsUsed(&kernel__numCPUs);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ebx,
                              &kernel__numCPUs,
                              sizeof(kernel__numCPUs));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetNumLogicalCPUsPerPackage --
 *
 * Generated from prototype:
 *   GetNumLogicalCPUsPerPackage(uint8 *numCPUs +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetNumLogicalCPUsPerPackage(VMKFullUserExcFrame * const rawFrame) {
    uint8 kernel__numCPUs;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetNumLogicalCPUsPerPackage);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetNumLogicalCPUsPerPackage(&kernel__numCPUs);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ebx,
                              &kernel__numCPUs,
                              sizeof(kernel__numCPUs));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetCPUIDs --
 *
 * Generated from prototype:
 *   GetCPUIDs(CPUIDSummary *cpuIDs, uint32 bufLen) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetCPUIDs(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetCPUIDs);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetCPUIDs((UserVA)(rawFrame->regs.ebx),
                                        (uint32)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackSetVMXInfo --
 *
 * Generated from prototype:
 *   SetVMXInfo(
 *   const char *cfgPath +STRING[WORLD_MAX_CONFIGFILE_SIZE],
 *    const char *uuidString +STRING[WORLD_MAX_UUIDTEXT_SIZE],
 *    const char *displayName +STRING[WORLD_MAX_DISPLAYNAME_SIZE]) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackSetVMXInfo(VMKFullUserExcFrame * const rawFrame) {
    char * kernel__cfgPath = NULL;
    char * kernel__uuidString = NULL;
    char * kernel__displayName = NULL;
    VMK_ReturnStatus status = VMK_OK;
    User_CartelInfo* uci = MY_USER_CARTEL_INFO;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_SetVMXInfo);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        kernel__cfgPath = (char *)User_HeapAlloc(uci, sizeof(char) * WORLD_MAX_CONFIGFILE_SIZE);
        if (kernel__cfgPath == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyInString(kernel__cfgPath,
                                   rawFrame->regs.ebx,
                                   WORLD_MAX_CONFIGFILE_SIZE);
    }
    if (status == VMK_OK) {
        kernel__uuidString = (char *)User_HeapAlloc(uci, sizeof(char) * WORLD_MAX_UUIDTEXT_SIZE);
        if (kernel__uuidString == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyInString(kernel__uuidString,
                                   rawFrame->regs.ecx,
                                   WORLD_MAX_UUIDTEXT_SIZE);
    }
    if (status == VMK_OK) {
        kernel__displayName = (char *)User_HeapAlloc(uci, sizeof(char) * WORLD_MAX_DISPLAYNAME_SIZE);
        if (kernel__displayName == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyInString(kernel__displayName,
                                   rawFrame->regs.edx,
                                   WORLD_MAX_DISPLAYNAME_SIZE);
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_SetVMXInfo(kernel__cfgPath,
                                         kernel__uuidString,
                                         kernel__displayName);
    }

    /* No output parameters */

    /* Free heap objects */
    if (kernel__cfgPath != NULL) {
       User_HeapFree(uci, kernel__cfgPath);
    }
    if (kernel__uuidString != NULL) {
       User_HeapFree(uci, kernel__uuidString);
    }
    if (kernel__displayName != NULL) {
       User_HeapFree(uci, kernel__displayName);
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackSetUID --
 *
 * Generated from prototype:
 *   SetUID() 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackSetUID(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_SetUID);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_SetUID();
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackSetupPhysMemMap --
 *
 * Generated from prototype:
 *   SetupPhysMemMap(PPN startPPN, uint32 length, void **addr) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackSetupPhysMemMap(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_SetupPhysMemMap);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_SetupPhysMemMap((PPN)(rawFrame->regs.ebx),
                                              (uint32)(rawFrame->regs.ecx),
                                              (UserVA)(rawFrame->regs.edx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackReleasePhysMemMap --
 *
 * Generated from prototype:
 *   ReleasePhysMemMap(void* vaddr, uint32 length) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackReleasePhysMemMap(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_ReleasePhysMemMap);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_ReleasePhysMemMap((UserVA)(rawFrame->regs.ebx),
                                                (uint32)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackMemTestMap --
 *
 * Generated from prototype:
 *   MemTestMap(MPN *inOutMPN, uint32 *numPages, void **addr) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackMemTestMap(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_MemTestMap);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_MemTestMap((UserVA)(rawFrame->regs.ebx),
                                         (UserVA)(rawFrame->regs.ecx),
                                         (UserVA)(rawFrame->regs.edx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackAsyncCheckActions --
 *
 * Generated from prototype:
 *   AsyncCheckActions(World_ID worldID) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackAsyncCheckActions(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_AsyncCheckActions);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_AsyncCheckActions((World_ID)(rawFrame->regs.ebx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackAddPage --
 *
 * Generated from prototype:
 *   AddPage(int32 vcpuID, VPN vpn, MPN mpn, int32 readOnly) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackAddPage(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_AddPage);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_AddPage((int32)(rawFrame->regs.ebx),
                                      (VPN)(rawFrame->regs.ecx),
                                      (MPN)(rawFrame->regs.edx),
                                      (int32)(rawFrame->regs.esi));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackReadPage --
 *
 * Generated from prototype:
 *   ReadPage(World_ID worldID, VPN vpn, uint8* data) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackReadPage(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_ReadPage);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_ReadPage((World_ID)(rawFrame->regs.ebx),
                                       (VPN)(rawFrame->regs.ecx),
                                       (UserVA)(rawFrame->regs.edx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackReadRegs --
 *
 * Generated from prototype:
 *   ReadRegs(World_ID worldID,
 *    VMnix_ReadRegsResult* result +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackReadRegs(VMKFullUserExcFrame * const rawFrame) {
    VMnix_ReadRegsResult kernel__result;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_ReadRegs);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_ReadRegs((World_ID)(rawFrame->regs.ebx),
                                       &kernel__result);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ecx,
                              &kernel__result,
                              sizeof(kernel__result));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackRunWorld --
 *
 * Generated from prototype:
 *   RunWorld(World_ID worldID, VMnix_Entry start) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackRunWorld(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_RunWorld);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_RunWorld((World_ID)(rawFrame->regs.ebx),
                                       (VMnix_Entry)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackNetConnect --
 *
 * Generated from prototype:
 *   NetConnect(World_ID worldID,
 *    const char *name +STRING[VMNIX_DEVICE_NAME_LENGTH],
 *    Net_PortID *portID +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackNetConnect(VMKFullUserExcFrame * const rawFrame) {
    char * kernel__name = NULL;
    Net_PortID kernel__portID;
    VMK_ReturnStatus status = VMK_OK;
    User_CartelInfo* uci = MY_USER_CARTEL_INFO;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_NetConnect);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        kernel__name = (char *)User_HeapAlloc(uci, sizeof(char) * VMNIX_DEVICE_NAME_LENGTH);
        if (kernel__name == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyInString(kernel__name,
                                   rawFrame->regs.ecx,
                                   VMNIX_DEVICE_NAME_LENGTH);
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_NetConnect((World_ID)(rawFrame->regs.ebx),
                                         kernel__name,
                                         &kernel__portID);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.edx,
                              &kernel__portID,
                              sizeof(kernel__portID));
    }

    /* Free heap objects */
    if (kernel__name != NULL) {
       User_HeapFree(uci, kernel__name);
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackNetDisconnect --
 *
 * Generated from prototype:
 *   NetDisconnect(World_ID worldID, Net_PortID portID) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackNetDisconnect(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_NetDisconnect);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_NetDisconnect((World_ID)(rawFrame->regs.ebx),
                                            (Net_PortID)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackUsingVMKTcpIpStack --
 *
 * Generated from prototype:
 *   UsingVMKTcpIpStack() 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackUsingVMKTcpIpStack(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_UsingVMKTcpIpStack);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_UsingVMKTcpIpStack();
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackDelaySCSICmds --
 *
 * Generated from prototype:
 *   DelaySCSICmds(uint32 delay) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackDelaySCSICmds(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_DelaySCSICmds);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_DelaySCSICmds((uint32)(rawFrame->regs.ebx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackPhysMemIO --
 *
 * Generated from prototype:
 *   PhysMemIO(int fd, uint32 offsetHi, uint32 offsetLo,
 *    int startPercent, int endPercent, Bool isRead) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackPhysMemIO(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_PhysMemIO);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_PhysMemIO((int)(rawFrame->regs.ebx),
                                        (uint32)(rawFrame->regs.ecx),
                                        (uint32)(rawFrame->regs.edx),
                                        (int)(rawFrame->regs.esi),
                                        (int)(rawFrame->regs.edi),
                                        (Bool)(rawFrame->regs.ebp));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackVSCSICreateDev --
 *
 * Generated from prototype:
 *   VSCSICreateDev(World_ID vmmLeader,
 *    VSCSI_DevDescriptor *desc +DEEPCOPY,
 *    VSCSI_HandleID *vcsiID +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackVSCSICreateDev(VMKFullUserExcFrame * const rawFrame) {
    VSCSI_DevDescriptor kernel__desc;
    VSCSI_HandleID kernel__vcsiID;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_VSCSICreateDev);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        status = User_CopyIn(&kernel__desc,
                             rawFrame->regs.ecx,
                             sizeof(kernel__desc));
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = VSCSI_CreateDevice((World_ID)(rawFrame->regs.ebx),
                                    &kernel__desc,
                                    &kernel__vcsiID);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.edx,
                              &kernel__vcsiID,
                              sizeof(kernel__vcsiID));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackVSCSIDestroyDev --
 *
 * Generated from prototype:
 *   VSCSIDestroyDev(World_ID vmmLeader,
 *    VSCSI_HandleID vcsiID) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackVSCSIDestroyDev(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_VSCSIDestroyDev);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = VSCSI_DestroyDevice((World_ID)(rawFrame->regs.ebx),
                                     (VSCSI_HandleID)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackOpenCowHierarchy --
 *
 * Generated from prototype:
 *   OpenCowHierarchy(
 *   FS_FileHandleID *fids +ARRAY[COW_MAX_REDO_LOG],
 *    int numFids, COW_HandleID *cid +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackOpenCowHierarchy(VMKFullUserExcFrame * const rawFrame) {
    FS_FileHandleID * kernel__fids = NULL;
    COW_HandleID kernel__cid;
    VMK_ReturnStatus status = VMK_OK;
    User_CartelInfo* uci = MY_USER_CARTEL_INFO;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_OpenCowHierarchy);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        kernel__fids = (FS_FileHandleID *)User_HeapAlloc(uci, sizeof(FS_FileHandleID) * COW_MAX_REDO_LOG);
        if (kernel__fids == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyIn(kernel__fids,
                             rawFrame->regs.ebx,
                             sizeof(FS_FileHandleID) * COW_MAX_REDO_LOG);
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = COW_OpenHierarchy(kernel__fids,
                                   (int)(rawFrame->regs.ecx),
                                   &kernel__cid);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.edx,
                              &kernel__cid,
                              sizeof(kernel__cid));
    }

    /* Free heap objects */
    if (kernel__fids != NULL) {
       User_HeapFree(uci, kernel__fids);
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackCowCombine --
 *
 * Generated from prototype:
 *   CowCombine(COW_HandleID *cid +DEEPCOPY,
 *    int linkOffsetFromBottom) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackCowCombine(VMKFullUserExcFrame * const rawFrame) {
    COW_HandleID kernel__cid;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_CowCombine);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        status = User_CopyIn(&kernel__cid,
                             rawFrame->regs.ebx,
                             sizeof(kernel__cid));
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = COW_Combine(&kernel__cid,
                             (int)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackMarkCheckpoint --
 *
 * Generated from prototype:
 *   MarkCheckpoint(Bool wakeup, Bool start) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackMarkCheckpoint(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_MarkCheckpoint);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_MarkCheckpoint((Bool)(rawFrame->regs.ebx),
                                             (Bool)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackCheckpointCleanup --
 *
 * Generated from prototype:
 *   CheckpointCleanup() 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackCheckpointCleanup(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_CheckpointCleanup);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_CheckpointCleanup();
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackSaveMemory --
 *
 * Generated from prototype:
 *   SaveMemory() 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackSaveMemory(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_SaveMemory);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_SaveMemory();
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackMigrateWriteCptData --
 *
 * Generated from prototype:
 *   MigrateWriteCptData(int offset, void *data, int size,
 *    Bool completed) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackMigrateWriteCptData(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_MigrateWriteCptData);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_MigrateWriteCptData((int)(rawFrame->regs.ebx),
                                                  (UserVA)(rawFrame->regs.ecx),
                                                  (int)(rawFrame->regs.edx),
                                                  (Bool)(rawFrame->regs.esi));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackMigratePollForData --
 *
 * Generated from prototype:
 *   MigratePollForData(
 *   VMnix_MigrateProgressResult *progress) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackMigratePollForData(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_MigratePollForData);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_MigratePollForData((UserVA)(rawFrame->regs.ebx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackMigrateReadCptData --
 *
 * Generated from prototype:
 *   MigrateReadCptData(int offset, void *dest, int size,
 *    int *sizeOut +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackMigrateReadCptData(VMKFullUserExcFrame * const rawFrame) {
    int kernel__sizeOut;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_MigrateReadCptData);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_MigrateReadCptData((int)(rawFrame->regs.ebx),
                                                 (UserVA)(rawFrame->regs.ecx),
                                                 (int)(rawFrame->regs.edx),
                                                 &kernel__sizeOut);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.esi,
                              &kernel__sizeOut,
                              sizeof(kernel__sizeOut));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackInitMigration --
 *
 * Generated from prototype:
 *   InitMigration(uint32 tsHi, uint32 tsLo, uint32 srcIpAddr,
 *    uint32 destIpAddr, World_ID destWorldID,
 *    Bool grabResources) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackInitMigration(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_InitMigration);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_InitMigration((uint32)(rawFrame->regs.ebx),
                                            (uint32)(rawFrame->regs.ecx),
                                            (uint32)(rawFrame->regs.edx),
                                            (uint32)(rawFrame->regs.esi),
                                            (World_ID)(rawFrame->regs.edi),
                                            (Bool)(rawFrame->regs.ebp));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackInb --
 *
 * Generated from prototype:
 *   Inb(uint32 port, uint8 *value +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackInb(VMKFullUserExcFrame * const rawFrame) {
    uint8 kernel__value;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_Inb);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_Inb((uint32)(rawFrame->regs.ebx),
                                  &kernel__value);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ecx,
                              &kernel__value,
                              sizeof(kernel__value));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackOutb --
 *
 * Generated from prototype:
 *   Outb(uint32 port, uint8 value) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackOutb(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_Outb);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_Outb((uint32)(rawFrame->regs.ebx),
                                   (uint8)(rawFrame->regs.ecx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackSysAlert --
 *
 * Generated from prototype:
 *   SysAlert(const char *msg +STRING[81]) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackSysAlert(VMKFullUserExcFrame * const rawFrame) {
    char * kernel__msg = NULL;
    VMK_ReturnStatus status = VMK_OK;
    User_CartelInfo* uci = MY_USER_CARTEL_INFO;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_SysAlert);

    /* Copy in parameters to the kernel */
    if (status == VMK_OK) {
        kernel__msg = (char *)User_HeapAlloc(uci, sizeof(char) * 81);
        if (kernel__msg == NULL) {
            status = VMK_NO_MEMORY;
        }
    }
    if (status == VMK_OK) {
        status = User_CopyInString(kernel__msg,
                                   rawFrame->regs.ebx,
                                   81);
    }

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_SysAlert(kernel__msg);
    }

    /* No output parameters */

    /* Free heap objects */
    if (kernel__msg != NULL) {
       User_HeapFree(uci, kernel__msg);
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackIsCosPidAlive --
 *
 * Generated from prototype:
 *   IsCosPidAlive(int cosPid) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackIsCosPidAlive(VMKFullUserExcFrame * const rawFrame) {
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_IsCosPidAlive);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_IsCosPidAlive((int)(rawFrame->regs.ebx));
    }

    /* No output parameters */

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}


/*
 *----------------------------------------------------------------------
 *
 * UWVMKSyscallUnpackGetCosProxyPid --
 *
 * Generated from prototype:
 *   GetCosProxyPid(int *cosPid +OUT) 
 *
 *----------------------------------------------------------------------
 */
static void
UWVMKSyscallUnpackGetCosProxyPid(VMKFullUserExcFrame * const rawFrame) {
    int kernel__cosPid;
    VMK_ReturnStatus status = VMK_OK;

    ASSERT(rawFrame != NULL);
    ASSERT(rawFrame->regs.eax == UWVMKSYSCALL_SYSCALLNUM_GetCosProxyPid);

    /* No copy-in parameters */

    /* Make the syscall */
    if (status == VMK_OK) {
        status = UWVMKSyscall_GetCosProxyPid(&kernel__cosPid);
    }

    /* Copy output parameters back into usermode */
    if (status == VMK_OK) {
        status = User_CopyOut(rawFrame->regs.ebx,
                              &kernel__cosPid,
                              sizeof(kernel__cosPid));
    }

    /* Set VMK_ReturnStatus in syscall result register */
    rawFrame->regs.eax = status;
    rawFrame->regs.ebx = User_TranslateStatus(status);
}
