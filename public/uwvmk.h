/*                                                -*-buffer-read-only: t-*-
 * **********************************************************
 * Copyright 2004 VMware, Inc.  All rights reserved. -- VMware Confidential
 * **********************************************************
 */

/*
 * uwvmk.h --
 *
 * AUTOMATICALLY GENERATED FILE.  HAND EDITS WILL BE LOST!
 *
 * Generated by  : bora/support/scripts/syscallGen.pl (via support/scripts/uwvmkGen)
 * Generated from: bora/vmkernel/user/uwvmkSyscall.list
 */

#ifndef UWVMKSYSCALL_GENERATED_UWVMK_H
#define UWVMKSYSCALL_GENERATED_UWVMK_H

#define INCLUDE_ALLOW_USERLEVEL
#include "includeCheck.h"

#include <errno.h>
#include "vm_basic_types.h"
#include "vmk_basic_types.h"
#include "cpuid_info.h"
#include "return_status.h"
#include "rpc_types.h"
#include "memsched_defs.h"
#include "vmnix_syscall.h"

static int VMKernel_GetSyscallVersion(uint32* version);
static int VMKernel_LockPage(VPN userVPN,
                             MPN* outMPN);
static int VMKernel_ProbeMPN(VPN userVPN,
                             MPN* outMPN);
static int VMKernel_GetNextAnonPage(World_ID worldID,
                                    MPN inMPN,
                                    MPN* outMPN);
static int VMKernel_ReadVMKStack(World_ID worldId,
                                 int pageNum,
                                 uint8* data,
                                 VA* vaddr);
static int VMKernel_GetMPNContents(MPN mpn,
                                   uint8* buf);
static int VMKernel_SetMPNContents(MPN mpn,
                                   const uint8* buf);
static int VMKernel_BreakIntoDebugger(void* fullFrame);
static int VMKernel_LiveCoreDump(char * coreFileName,
                                 int coreFileNameLen);
static int VMKernel_RPCConnect(const char * name,
                               int * cnxFD,
                               int32 * cnxID);
static int VMKernel_RPCGetMsg(int32 cnxFD,
                              RPC_MsgInfo * msgInfo,
                              uint32 timeout,
                              int32 isBlocking,
                              World_ID switchToWorldID);
static int VMKernel_RPCSendMsg(int32 cnxFD,
                               int32 rpcFunction,
                               char * msgBuf,
                               int32 msgBufLen);
static int VMKernel_RPCReply(int32 cnxFD,
                             int32 token);
static int VMKernel_CreateVCPU(VMnix_CreateWorldArgs * args,
                               SharedAreaDesc * desc,
                               World_ID * worldID);
static int VMKernel_BindVCPU(World_ID groupLeaderID,
                             int32 vcpuID,
                             World_ID * worldID);
static int VMKernel_ReleaseAllVCPUs(void);
static int VMKernel_GetCPUkhzEstimate(uint32 * cpukHzEstimate);
static int VMKernel_GetNumCPUsUsed(uint32 * numCPUs);
static int VMKernel_GetNumLogicalCPUsPerPackage(uint8 * numCPUs);
static int VMKernel_GetCPUIDs(CPUIDSummary * cpuIDs,
                              uint32 bufLen);
static int VMKernel_SetVMXInfo(const char * cfgPath,
                               const char * uuidString,
                               const char * displayName);
static int VMKernel_SetUID(void);
static int VMKernel_SetupPhysMemMap(PPN startPPN,
                                    uint32 length,
                                    void ** addr);
static int VMKernel_ReleasePhysMemMap(void* vaddr,
                                      uint32 length);
static int VMKernel_MemTestMap(MPN * inOutMPN,
                               uint32 * numPages,
                               void ** addr);
static int VMKernel_AsyncCheckActions(World_ID worldID);
static int VMKernel_AddPage(int32 vcpuID,
                            VPN vpn,
                            MPN mpn,
                            int32 readOnly);
static int VMKernel_ReadPage(World_ID worldID,
                             VPN vpn,
                             uint8* data);
static int VMKernel_ReadRegs(World_ID worldID,
                             VMnix_ReadRegsResult* result);
static int VMKernel_RunWorld(World_ID worldID,
                             VMnix_Entry start);
static int VMKernel_NetConnect(World_ID worldID,
                               const char * name,
                               Net_PortID * portID);
static int VMKernel_NetDisconnect(World_ID worldID,
                                  Net_PortID portID);
static int VMKernel_UsingVMKTcpIpStack(void);
static int VMKernel_DelaySCSICmds(uint32 delay);
static int VMKernel_PhysMemIO(int fd,
                              uint32 offsetHi,
                              uint32 offsetLo,
                              int startPercent,
                              int endPercent,
                              Bool isRead);
static int VMKernel_VSCSICreateDev(World_ID vmmLeader,
                                   VSCSI_DevDescriptor * desc,
                                   VSCSI_HandleID * vcsiID);
static int VMKernel_VSCSIDestroyDev(World_ID vmmLeader,
                                    VSCSI_HandleID vcsiID);
static int VMKernel_OpenCowHierarchy(FS_FileHandleID * fids,
                                     int numFids,
                                     COW_HandleID * cid);
static int VMKernel_CowCombine(COW_HandleID * cid,
                               int linkOffsetFromBottom);
static int VMKernel_MarkCheckpoint(Bool wakeup,
                                   Bool start);
static int VMKernel_CheckpointCleanup(void);
static int VMKernel_SaveMemory(void);
static int VMKernel_MigrateWriteCptData(int offset,
                                        void * data,
                                        int size,
                                        Bool completed);
static int VMKernel_MigratePollForData(VMnix_MigrateProgressResult * progress);
static int VMKernel_MigrateReadCptData(int offset,
                                       void * dest,
                                       int size,
                                       int * sizeOut);
static int VMKernel_InitMigration(uint32 tsHi,
                                  uint32 tsLo,
                                  uint32 srcIpAddr,
                                  uint32 destIpAddr,
                                  World_ID destWorldID,
                                  Bool grabResources);
static int VMKernel_Inb(uint32 port,
                        uint8 * value);
static int VMKernel_Outb(uint32 port,
                         uint8 value);
static int VMKernel_SysAlert(const char * msg);
static int VMKernel_IsCosPidAlive(int cosPid);
static int VMKernel_GetCosProxyPid(int * cosPid);

#define UWVMKSYSCALL_CHECKSUM 0x8117266a

/*
 * UWVMKSyscall syscall numbers.
 */
typedef enum {
    UWVMKSYSCALL_SYSCALLNUM_GetSyscallVersion               = 0,
    UWVMKSYSCALL_SYSCALLNUM_LockPage                        = 1,
    UWVMKSYSCALL_SYSCALLNUM_ProbeMPN                        = 2,
    UWVMKSYSCALL_SYSCALLNUM_GetNextAnonPage                 = 3,
    UWVMKSYSCALL_SYSCALLNUM_ReadVMKStack                    = 4,
    UWVMKSYSCALL_SYSCALLNUM_GetMPNContents                  = 5,
    UWVMKSYSCALL_SYSCALLNUM_SetMPNContents                  = 6,
    UWVMKSYSCALL_SYSCALLNUM_BreakIntoDebugger               = 7,
    UWVMKSYSCALL_SYSCALLNUM_LiveCoreDump                    = 8,
    UWVMKSYSCALL_SYSCALLNUM_RPCConnect                      = 9,
    UWVMKSYSCALL_SYSCALLNUM_RPCGetMsg                       = 10,
    UWVMKSYSCALL_SYSCALLNUM_RPCSendMsg                      = 11,
    UWVMKSYSCALL_SYSCALLNUM_RPCReply                        = 12,
    UWVMKSYSCALL_SYSCALLNUM_CreateVCPU                      = 13,
    UWVMKSYSCALL_SYSCALLNUM_BindVCPU                        = 14,
    UWVMKSYSCALL_SYSCALLNUM_ReleaseAllVCPUs                 = 15,
    UWVMKSYSCALL_SYSCALLNUM_GetCPUkhzEstimate               = 16,
    UWVMKSYSCALL_SYSCALLNUM_GetNumCPUsUsed                  = 17,
    UWVMKSYSCALL_SYSCALLNUM_GetNumLogicalCPUsPerPackage     = 18,
    UWVMKSYSCALL_SYSCALLNUM_GetCPUIDs                       = 19,
    UWVMKSYSCALL_SYSCALLNUM_SetVMXInfo                      = 20,
    UWVMKSYSCALL_SYSCALLNUM_SetUID                          = 21,
    UWVMKSYSCALL_SYSCALLNUM_SetupPhysMemMap                 = 22,
    UWVMKSYSCALL_SYSCALLNUM_ReleasePhysMemMap               = 23,
    UWVMKSYSCALL_SYSCALLNUM_MemTestMap                      = 24,
    UWVMKSYSCALL_SYSCALLNUM_AsyncCheckActions               = 25,
    UWVMKSYSCALL_SYSCALLNUM_AddPage                         = 26,
    UWVMKSYSCALL_SYSCALLNUM_ReadPage                        = 27,
    UWVMKSYSCALL_SYSCALLNUM_ReadRegs                        = 28,
    UWVMKSYSCALL_SYSCALLNUM_RunWorld                        = 29,
    UWVMKSYSCALL_SYSCALLNUM_NetConnect                      = 30,
    UWVMKSYSCALL_SYSCALLNUM_NetDisconnect                   = 31,
    UWVMKSYSCALL_SYSCALLNUM_UsingVMKTcpIpStack              = 32,
    UWVMKSYSCALL_SYSCALLNUM_DelaySCSICmds                   = 33,
    UWVMKSYSCALL_SYSCALLNUM_PhysMemIO                       = 34,
    UWVMKSYSCALL_SYSCALLNUM_VSCSICreateDev                  = 35,
    UWVMKSYSCALL_SYSCALLNUM_VSCSIDestroyDev                 = 36,
    UWVMKSYSCALL_SYSCALLNUM_OpenCowHierarchy                = 37,
    UWVMKSYSCALL_SYSCALLNUM_CowCombine                      = 38,
    UWVMKSYSCALL_SYSCALLNUM_MarkCheckpoint                  = 39,
    UWVMKSYSCALL_SYSCALLNUM_CheckpointCleanup               = 40,
    UWVMKSYSCALL_SYSCALLNUM_SaveMemory                      = 41,
    UWVMKSYSCALL_SYSCALLNUM_MigrateWriteCptData             = 42,
    UWVMKSYSCALL_SYSCALLNUM_MigratePollForData              = 43,
    UWVMKSYSCALL_SYSCALLNUM_MigrateReadCptData              = 44,
    UWVMKSYSCALL_SYSCALLNUM_InitMigration                   = 45,
    UWVMKSYSCALL_SYSCALLNUM_Inb                             = 46,
    UWVMKSYSCALL_SYSCALLNUM_Outb                            = 47,
    UWVMKSYSCALL_SYSCALLNUM_SysAlert                        = 48,
    UWVMKSYSCALL_SYSCALLNUM_IsCosPidAlive                   = 49,
    UWVMKSYSCALL_SYSCALLNUM_GetCosProxyPid                  = 50,
    UWVMKSYSCALL_SYSCALLNUM_MAX                             = 51,
} UWVMKSyscall_Number;



/*
 * A bit of a hack to ensure all the non-pointer parameter types will fit
 * in a register.
 *
 * Works by aligning (useless) struct to the result of EXPR. Since alignment
 * to 0 is not allowed, the compiler will abort in that case with:
 *     error: requested alignment is not a power of 2
 *
 */
#define SIZECHECK(ID, EXPR) struct VMKernel_ParamSizeCheck##ID { int x; } __attribute__((__aligned__ (EXPR)))

SIZECHECK(0, (sizeof(void*) <= sizeof(uint32))); /* All pointers */
SIZECHECK(1, (sizeof(Bool) <= sizeof(uint32)));
SIZECHECK(2, (sizeof(MPN) <= sizeof(uint32)));
SIZECHECK(3, (sizeof(Net_PortID) <= sizeof(uint32)));
SIZECHECK(4, (sizeof(PPN) <= sizeof(uint32)));
SIZECHECK(5, (sizeof(VMnix_Entry) <= sizeof(uint32)));
SIZECHECK(6, (sizeof(VPN) <= sizeof(uint32)));
SIZECHECK(7, (sizeof(VSCSI_HandleID) <= sizeof(uint32)));
SIZECHECK(8, (sizeof(World_ID) <= sizeof(uint32)));
SIZECHECK(9, (sizeof(int) <= sizeof(uint32)));
SIZECHECK(10, (sizeof(int32) <= sizeof(uint32)));
SIZECHECK(11, (sizeof(uint32) <= sizeof(uint32)));
SIZECHECK(12, (sizeof(uint8) <= sizeof(uint32)));


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetSyscallVersion --
 *
 * Generated automatically from the prototype:
 *   GetSyscallVersion(uint32* version +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetSyscallVersion(uint32* version)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetSyscallVersion)
        ,"b" (version)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_LockPage --
 *
 * Generated automatically from the prototype:
 *   LockPage(VPN userVPN, MPN* outMPN +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_LockPage(VPN userVPN,
                  MPN* outMPN)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_LockPage)
        ,"b" (userVPN)
        ,"c" (outMPN)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_ProbeMPN --
 *
 * Generated automatically from the prototype:
 *   ProbeMPN(VPN userVPN, MPN* outMPN +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_ProbeMPN(VPN userVPN,
                  MPN* outMPN)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_ProbeMPN)
        ,"b" (userVPN)
        ,"c" (outMPN)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetNextAnonPage --
 *
 * Generated automatically from the prototype:
 *   GetNextAnonPage(World_ID worldID, MPN inMPN,
 *    MPN* outMPN +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetNextAnonPage(World_ID worldID,
                         MPN inMPN,
                         MPN* outMPN)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetNextAnonPage)
        ,"b" (worldID)
        ,"c" (inMPN)
        ,"d" (outMPN)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_ReadVMKStack --
 *
 * Generated automatically from the prototype:
 *   ReadVMKStack(World_ID worldId, int pageNum, uint8* data,
 *    VA* vaddr +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_ReadVMKStack(World_ID worldId,
                      int pageNum,
                      uint8* data,
                      VA* vaddr)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_ReadVMKStack)
        ,"b" (worldId)
        ,"c" (pageNum)
        ,"d" (data)
        ,"S" ((uint32)vaddr)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetMPNContents --
 *
 * Generated automatically from the prototype:
 *   GetMPNContents(MPN mpn, uint8* buf)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetMPNContents(MPN mpn,
                        uint8* buf)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetMPNContents)
        ,"b" (mpn)
        ,"c" (buf)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_SetMPNContents --
 *
 * Generated automatically from the prototype:
 *   SetMPNContents(MPN mpn, const uint8* buf)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_SetMPNContents(MPN mpn,
                        const uint8* buf)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_SetMPNContents)
        ,"b" (mpn)
        ,"c" (buf)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_BreakIntoDebugger --
 *
 * Generated automatically from the prototype:
 *   BreakIntoDebugger(void* fullFrame)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_BreakIntoDebugger(void* fullFrame)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_BreakIntoDebugger)
        ,"b" (fullFrame)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_LiveCoreDump --
 *
 * Generated automatically from the prototype:
 *   LiveCoreDump(char *coreFileName, int coreFileNameLen)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_LiveCoreDump(char * coreFileName,
                      int coreFileNameLen)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_LiveCoreDump)
        ,"b" (coreFileName)
        ,"c" (coreFileNameLen)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_RPCConnect --
 *
 * Generated automatically from the prototype:
 *   RPCConnect(
 *   const char *name +STRING[RPC_CNX_NAME_LENGTH],
 *    int *cnxFD +OUT, int32 *cnxID +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_RPCConnect(const char * name,
                    int * cnxFD,
                    int32 * cnxID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_RPCConnect)
        ,"b" (name)
        ,"c" (cnxFD)
        ,"d" (cnxID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_RPCGetMsg --
 *
 * Generated automatically from the prototype:
 *   RPCGetMsg(int32 cnxFD, RPC_MsgInfo *msgInfo,
 *    uint32 timeout, int32 isBlocking,
 *    World_ID switchToWorldID)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_RPCGetMsg(int32 cnxFD,
                   RPC_MsgInfo * msgInfo,
                   uint32 timeout,
                   int32 isBlocking,
                   World_ID switchToWorldID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_RPCGetMsg)
        ,"b" (cnxFD)
        ,"c" (msgInfo)
        ,"d" (timeout)
        ,"S" ((uint32)isBlocking)
        ,"D" ((uint32)switchToWorldID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_RPCSendMsg --
 *
 * Generated automatically from the prototype:
 *   RPCSendMsg(int32 cnxFD, int32 rpcFunction, char *msgBuf,
 *    int32 msgBufLen)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_RPCSendMsg(int32 cnxFD,
                    int32 rpcFunction,
                    char * msgBuf,
                    int32 msgBufLen)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_RPCSendMsg)
        ,"b" (cnxFD)
        ,"c" (rpcFunction)
        ,"d" (msgBuf)
        ,"S" ((uint32)msgBufLen)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_RPCReply --
 *
 * Generated automatically from the prototype:
 *   RPCReply(int32 cnxFD, int32 token)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_RPCReply(int32 cnxFD,
                  int32 token)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_RPCReply)
        ,"b" (cnxFD)
        ,"c" (token)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_CreateVCPU --
 *
 * Generated automatically from the prototype:
 *   CreateVCPU(VMnix_CreateWorldArgs *args +DEEPCOPY,
 *    SharedAreaDesc *desc +ARRAY[MAX_SHARED_AREA_DESC],
 *    World_ID *worldID +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_CreateVCPU(VMnix_CreateWorldArgs * args,
                    SharedAreaDesc * desc,
                    World_ID * worldID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_CreateVCPU)
        ,"b" (args)
        ,"c" (desc)
        ,"d" (worldID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_BindVCPU --
 *
 * Generated automatically from the prototype:
 *   BindVCPU(World_ID groupLeaderID, int32 vcpuID,
 *    World_ID *worldID +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_BindVCPU(World_ID groupLeaderID,
                  int32 vcpuID,
                  World_ID * worldID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_BindVCPU)
        ,"b" (groupLeaderID)
        ,"c" (vcpuID)
        ,"d" (worldID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_ReleaseAllVCPUs --
 *
 * Generated automatically from the prototype:
 *   ReleaseAllVCPUs()
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_ReleaseAllVCPUs(void)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_ReleaseAllVCPUs)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetCPUkhzEstimate --
 *
 * Generated automatically from the prototype:
 *   GetCPUkhzEstimate(uint32 *cpukHzEstimate +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetCPUkhzEstimate(uint32 * cpukHzEstimate)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetCPUkhzEstimate)
        ,"b" (cpukHzEstimate)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetNumCPUsUsed --
 *
 * Generated automatically from the prototype:
 *   GetNumCPUsUsed(uint32 *numCPUs +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetNumCPUsUsed(uint32 * numCPUs)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetNumCPUsUsed)
        ,"b" (numCPUs)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetNumLogicalCPUsPerPackage --
 *
 * Generated automatically from the prototype:
 *   GetNumLogicalCPUsPerPackage(uint8 *numCPUs +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetNumLogicalCPUsPerPackage(uint8 * numCPUs)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetNumLogicalCPUsPerPackage)
        ,"b" (numCPUs)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetCPUIDs --
 *
 * Generated automatically from the prototype:
 *   GetCPUIDs(CPUIDSummary *cpuIDs, uint32 bufLen)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetCPUIDs(CPUIDSummary * cpuIDs,
                   uint32 bufLen)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetCPUIDs)
        ,"b" (cpuIDs)
        ,"c" (bufLen)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_SetVMXInfo --
 *
 * Generated automatically from the prototype:
 *   SetVMXInfo(
 *   const char *cfgPath +STRING[WORLD_MAX_CONFIGFILE_SIZE],
 *    const char *uuidString +STRING[WORLD_MAX_UUIDTEXT_SIZE],
 *    const char *displayName +STRING[WORLD_MAX_DISPLAYNAME_SIZE])
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_SetVMXInfo(const char * cfgPath,
                    const char * uuidString,
                    const char * displayName)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_SetVMXInfo)
        ,"b" (cfgPath)
        ,"c" (uuidString)
        ,"d" (displayName)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_SetUID --
 *
 * Generated automatically from the prototype:
 *   SetUID()
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_SetUID(void)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_SetUID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_SetupPhysMemMap --
 *
 * Generated automatically from the prototype:
 *   SetupPhysMemMap(PPN startPPN, uint32 length, void **addr)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_SetupPhysMemMap(PPN startPPN,
                         uint32 length,
                         void ** addr)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_SetupPhysMemMap)
        ,"b" (startPPN)
        ,"c" (length)
        ,"d" (addr)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_ReleasePhysMemMap --
 *
 * Generated automatically from the prototype:
 *   ReleasePhysMemMap(void* vaddr, uint32 length)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_ReleasePhysMemMap(void* vaddr,
                           uint32 length)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_ReleasePhysMemMap)
        ,"b" (vaddr)
        ,"c" (length)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_MemTestMap --
 *
 * Generated automatically from the prototype:
 *   MemTestMap(MPN *inOutMPN, uint32 *numPages, void **addr)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_MemTestMap(MPN * inOutMPN,
                    uint32 * numPages,
                    void ** addr)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_MemTestMap)
        ,"b" (inOutMPN)
        ,"c" (numPages)
        ,"d" (addr)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_AsyncCheckActions --
 *
 * Generated automatically from the prototype:
 *   AsyncCheckActions(World_ID worldID)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_AsyncCheckActions(World_ID worldID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_AsyncCheckActions)
        ,"b" (worldID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_AddPage --
 *
 * Generated automatically from the prototype:
 *   AddPage(int32 vcpuID, VPN vpn, MPN mpn, int32 readOnly)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_AddPage(int32 vcpuID,
                 VPN vpn,
                 MPN mpn,
                 int32 readOnly)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_AddPage)
        ,"b" (vcpuID)
        ,"c" (vpn)
        ,"d" (mpn)
        ,"S" ((uint32)readOnly)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_ReadPage --
 *
 * Generated automatically from the prototype:
 *   ReadPage(World_ID worldID, VPN vpn, uint8* data)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_ReadPage(World_ID worldID,
                  VPN vpn,
                  uint8* data)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_ReadPage)
        ,"b" (worldID)
        ,"c" (vpn)
        ,"d" (data)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_ReadRegs --
 *
 * Generated automatically from the prototype:
 *   ReadRegs(World_ID worldID,
 *    VMnix_ReadRegsResult* result +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_ReadRegs(World_ID worldID,
                  VMnix_ReadRegsResult* result)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_ReadRegs)
        ,"b" (worldID)
        ,"c" (result)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_RunWorld --
 *
 * Generated automatically from the prototype:
 *   RunWorld(World_ID worldID, VMnix_Entry start)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_RunWorld(World_ID worldID,
                  VMnix_Entry start)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_RunWorld)
        ,"b" (worldID)
        ,"c" (start)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_NetConnect --
 *
 * Generated automatically from the prototype:
 *   NetConnect(World_ID worldID,
 *    const char *name +STRING[VMNIX_DEVICE_NAME_LENGTH],
 *    Net_PortID *portID +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_NetConnect(World_ID worldID,
                    const char * name,
                    Net_PortID * portID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_NetConnect)
        ,"b" (worldID)
        ,"c" (name)
        ,"d" (portID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_NetDisconnect --
 *
 * Generated automatically from the prototype:
 *   NetDisconnect(World_ID worldID, Net_PortID portID)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_NetDisconnect(World_ID worldID,
                       Net_PortID portID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_NetDisconnect)
        ,"b" (worldID)
        ,"c" (portID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_UsingVMKTcpIpStack --
 *
 * Generated automatically from the prototype:
 *   UsingVMKTcpIpStack()
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_UsingVMKTcpIpStack(void)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_UsingVMKTcpIpStack)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_DelaySCSICmds --
 *
 * Generated automatically from the prototype:
 *   DelaySCSICmds(uint32 delay)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_DelaySCSICmds(uint32 delay)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_DelaySCSICmds)
        ,"b" (delay)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_PhysMemIO --
 *
 * Generated automatically from the prototype:
 *   PhysMemIO(int fd, uint32 offsetHi, uint32 offsetLo,
 *    int startPercent, int endPercent, Bool isRead)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_PhysMemIO(int fd,
                   uint32 offsetHi,
                   uint32 offsetLo,
                   int startPercent,
                   int endPercent,
                   Bool isRead)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "push %%ebp\n"        \
        "movl %%eax, %%ebp\n" \
        "movl %2, %%eax\n"    \
        "int $0x90\n"         \
        "pop %%ebp\n"           
        : /*output:*/           
        "=a" (rc),              
        "=b" (linuxrc)          
        : /*input:*/            
        "i" (UWVMKSYSCALL_SYSCALLNUM_PhysMemIO),
        "b" (fd),
        "c" (offsetHi),
        "d" (offsetLo),
        "S" ((uint32)startPercent),
        "D" ((uint32)endPercent),
        "0" (isRead)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_VSCSICreateDev --
 *
 * Generated automatically from the prototype:
 *   VSCSICreateDev(World_ID vmmLeader,
 *    VSCSI_DevDescriptor *desc +DEEPCOPY,
 *    VSCSI_HandleID *vcsiID +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_VSCSICreateDev(World_ID vmmLeader,
                        VSCSI_DevDescriptor * desc,
                        VSCSI_HandleID * vcsiID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_VSCSICreateDev)
        ,"b" (vmmLeader)
        ,"c" (desc)
        ,"d" (vcsiID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_VSCSIDestroyDev --
 *
 * Generated automatically from the prototype:
 *   VSCSIDestroyDev(World_ID vmmLeader,
 *    VSCSI_HandleID vcsiID)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_VSCSIDestroyDev(World_ID vmmLeader,
                         VSCSI_HandleID vcsiID)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_VSCSIDestroyDev)
        ,"b" (vmmLeader)
        ,"c" (vcsiID)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_OpenCowHierarchy --
 *
 * Generated automatically from the prototype:
 *   OpenCowHierarchy(
 *   FS_FileHandleID *fids +ARRAY[COW_MAX_REDO_LOG],
 *    int numFids, COW_HandleID *cid +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_OpenCowHierarchy(FS_FileHandleID * fids,
                          int numFids,
                          COW_HandleID * cid)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_OpenCowHierarchy)
        ,"b" (fids)
        ,"c" (numFids)
        ,"d" (cid)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_CowCombine --
 *
 * Generated automatically from the prototype:
 *   CowCombine(COW_HandleID *cid +DEEPCOPY,
 *    int linkOffsetFromBottom)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_CowCombine(COW_HandleID * cid,
                    int linkOffsetFromBottom)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_CowCombine)
        ,"b" (cid)
        ,"c" (linkOffsetFromBottom)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_MarkCheckpoint --
 *
 * Generated automatically from the prototype:
 *   MarkCheckpoint(Bool wakeup, Bool start)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_MarkCheckpoint(Bool wakeup,
                        Bool start)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_MarkCheckpoint)
        ,"b" (wakeup)
        ,"c" (start)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_CheckpointCleanup --
 *
 * Generated automatically from the prototype:
 *   CheckpointCleanup()
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_CheckpointCleanup(void)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_CheckpointCleanup)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_SaveMemory --
 *
 * Generated automatically from the prototype:
 *   SaveMemory()
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_SaveMemory(void)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_SaveMemory)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_MigrateWriteCptData --
 *
 * Generated automatically from the prototype:
 *   MigrateWriteCptData(int offset, void *data, int size,
 *    Bool completed)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_MigrateWriteCptData(int offset,
                             void * data,
                             int size,
                             Bool completed)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_MigrateWriteCptData)
        ,"b" (offset)
        ,"c" (data)
        ,"d" (size)
        ,"S" ((uint32)completed)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_MigratePollForData --
 *
 * Generated automatically from the prototype:
 *   MigratePollForData(
 *   VMnix_MigrateProgressResult *progress)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_MigratePollForData(VMnix_MigrateProgressResult * progress)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_MigratePollForData)
        ,"b" (progress)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_MigrateReadCptData --
 *
 * Generated automatically from the prototype:
 *   MigrateReadCptData(int offset, void *dest, int size,
 *    int *sizeOut +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_MigrateReadCptData(int offset,
                            void * dest,
                            int size,
                            int * sizeOut)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_MigrateReadCptData)
        ,"b" (offset)
        ,"c" (dest)
        ,"d" (size)
        ,"S" ((uint32)sizeOut)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_InitMigration --
 *
 * Generated automatically from the prototype:
 *   InitMigration(uint32 tsHi, uint32 tsLo, uint32 srcIpAddr,
 *    uint32 destIpAddr, World_ID destWorldID,
 *    Bool grabResources)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_InitMigration(uint32 tsHi,
                       uint32 tsLo,
                       uint32 srcIpAddr,
                       uint32 destIpAddr,
                       World_ID destWorldID,
                       Bool grabResources)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "push %%ebp\n"        \
        "movl %%eax, %%ebp\n" \
        "movl %2, %%eax\n"    \
        "int $0x90\n"         \
        "pop %%ebp\n"           
        : /*output:*/           
        "=a" (rc),              
        "=b" (linuxrc)          
        : /*input:*/            
        "i" (UWVMKSYSCALL_SYSCALLNUM_InitMigration),
        "b" (tsHi),
        "c" (tsLo),
        "d" (srcIpAddr),
        "S" ((uint32)destIpAddr),
        "D" ((uint32)destWorldID),
        "0" (grabResources)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_Inb --
 *
 * Generated automatically from the prototype:
 *   Inb(uint32 port, uint8 *value +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_Inb(uint32 port,
             uint8 * value)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_Inb)
        ,"b" (port)
        ,"c" (value)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_Outb --
 *
 * Generated automatically from the prototype:
 *   Outb(uint32 port, uint8 value)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_Outb(uint32 port,
              uint8 value)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_Outb)
        ,"b" (port)
        ,"c" (value)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_SysAlert --
 *
 * Generated automatically from the prototype:
 *   SysAlert(const char *msg +STRING[81])
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_SysAlert(const char * msg)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_SysAlert)
        ,"b" (msg)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_IsCosPidAlive --
 *
 * Generated automatically from the prototype:
 *   IsCosPidAlive(int cosPid)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_IsCosPidAlive(int cosPid)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_IsCosPidAlive)
        ,"b" (cosPid)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}


/*
 *----------------------------------------------------------------------
 *
 * VMKernel_GetCosProxyPid --
 *
 * Generated automatically from the prototype:
 *   GetCosProxyPid(int *cosPid +OUT)
 *
 *----------------------------------------------------------------------
 */
static inline int
VMKernel_GetCosProxyPid(int * cosPid)
{
    uint32 rc = 0;
    uint32 linuxrc = 0;
    __asm__ volatile (
        "movl %2, %%eax\n"  \
        "int $0x90\n"         
        : /*output:*/         
        "=a" (rc),            
        "=b" (linuxrc)        
        : /*input:*/          
        "i" (UWVMKSYSCALL_SYSCALLNUM_GetCosProxyPid)
        ,"b" (cosPid)
    );
    if (linuxrc != 0) {
       errno = -linuxrc;
    }
    return rc;
}
#endif /* UWVMKSYSCALL_GENERATED_UWVMK_H */
